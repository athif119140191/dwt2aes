import numpy as np
import cv2
import pywt
import binascii
from concurrent.futures import ThreadPoolExecutor
from Crypto.Cipher import AES
from Crypto.Util import Counter
import threading
import time
import psutil
import os
import subprocess
import math

def aes_ctr_encrypt(plaintext, key, nonce):
    """Enkripsi AES-CTR secara paralel"""
    block_size = 16
    blocks = [plaintext[i:i + block_size] for i in range(0, len(plaintext), block_size)]

    def encrypt_block(index, block):
        ctr = Counter.new(64, prefix=nonce.to_bytes(8, 'big'), initial_value=index)
        cipher = AES.new(key, AES.MODE_CTR, counter=ctr)
        return cipher.encrypt(block)

    with ThreadPoolExecutor() as executor:
        results = list(executor.map(lambda x: encrypt_block(x[0], x[1]), enumerate(blocks)))

    return b"".join(results)

def monitor_resource(process, interval, stop_event, cpu_samples, ram_samples):
    """
    Monitor CPU (%) dan RAM (MB) selama proses berjalan
    """
    while not stop_event.is_set():
        cpu = process.cpu_percent(interval=None)
        ram = process.memory_info().rss / (1024 ** 2)  # MB
        cpu_samples.append(cpu)
        ram_samples.append(ram)
        time.sleep(interval)

def sisip_pesan_logic(cover_img, pesan_terenkripsi_hex, nonce, selected_layer, selected_signal,
                      cover_video_path, cover_frame_index, codec_dropdown_get, ffmpeg_available):
    """
    Melakukan penyisipan DWT dan pembuatan video stego.
    Mengembalikan stego_image, nilai PSNR/MOS, dan informasi video stego, serta path audio.
    """
    from gui.utils import calculate_psnr # Import lokal untuk menghindari circular dependency

    process = psutil.Process(os.getpid())

    cpu_samples = []
    ram_samples = []
    stop_event = threading.Event()

    monitor_thread = threading.Thread(
        target=monitor_resource,
        args=(process, 0.1, stop_event, cpu_samples, ram_samples),
        daemon=True
    )

    start_time = time.time()
    monitor_thread.start()

    cipher_bytes = binascii.unhexlify(pesan_terenkripsi_hex)
    
    panjang_byte_pesan = len(cipher_bytes)
    panjang_bit_pesan = panjang_byte_pesan * 8

    # Siapkan header
    panjang_bit_pesan_bin = format(panjang_bit_pesan, '016b')
    nonce_bin = format(nonce, '064b')
    bit_pesan = ''.join(format(b, '08b') for b in cipher_bytes)
    
    bit_pesan_full = panjang_bit_pesan_bin + nonce_bin + bit_pesan
    total_bits = len(bit_pesan_full)
    
    # Ambil frame cover
    full_img = cover_img
    
    if selected_layer == 'red': layer_index = 2
    elif selected_layer == 'green': layer_index = 1
    else: layer_index = 0
        
    layer = full_img[:, :, layer_index]

    # Lakukan DWT
    coeffs = pywt.dwt2(layer, 'haar')
    LL, (LH, HL, HH) = coeffs

    if selected_signal == 'LL': used_signal = LL
    elif selected_signal == 'LH': used_signal = LH
    elif selected_signal == 'HL': used_signal = HL
    else: used_signal = HH
    
    signal_sebaris = used_signal.flatten()
    
    if total_bits > len(signal_sebaris):
        raise ValueError(f"Ukuran pesan melebihi kapasitas gambar. Diperlukan: {total_bits} bit, Kapasitas: {len(signal_sebaris)} bit")

    # Tentukan embedding strength
    mean_val = np.mean(np.abs(signal_sebaris))
    if selected_signal == 'LL': embedding_strength = mean_val * 0.5
    else: embedding_strength = mean_val * 2.0
    embedding_strength = max(embedding_strength, 10.0) # Minimum strength
    
    # Lakukan penyisipan bit
    new_signal_sebaris = np.copy(signal_sebaris)
    quant_level = int(10)

    for i in range(total_bits):
        bit = int(bit_pesan_full[i])
        current_val = signal_sebaris[i]
        
        current_quantized = round(current_val / quant_level) * quant_level
        
        if bit == 1:
            new_val = abs(current_quantized) + quant_level
        else:
            new_val = -abs(current_quantized) - quant_level
            
        new_signal_sebaris[i] = new_val

    # Gabungkan kembali subband yang sudah dimodifikasi
    new_used_signal = new_signal_sebaris.reshape(used_signal.shape)
    
    if selected_signal == 'LL': new_coeffs = (new_used_signal, (LH, HL, HH))
    elif selected_signal == 'LH': new_coeffs = (LL, (new_used_signal, HL, HH))
    elif selected_signal == 'HL': new_coeffs = (LL, (LH, new_used_signal, HH))
    else: new_coeffs = (LL, (LH, HL, new_used_signal))
        
    # Lakukan Inverse DWT
    new_layer = pywt.idwt2(new_coeffs, 'haar')
    new_layer = np.clip(new_layer, 0, 255).astype(np.uint8)

    # Gabungkan kembali layer
    stego_image = full_img.copy()
    stego_image[:, :, layer_index] = new_layer

    # Simpan frame stego sementara
    cv2.imwrite('stego_image.bmp', stego_image)

    # Hitung PSNR dan MOS
    nilai_psnr = calculate_psnr(full_img, stego_image)
    if nilai_psnr > 37: nilai_mos = 'Excellent'
    elif nilai_psnr > 31: nilai_mos = 'Good'
    elif nilai_psnr > 25: nilai_mos = 'Fair'
    elif nilai_psnr > 20: nilai_mos = 'Poor'
    else: nilai_mos = 'Bad'
        
    # --- LOGIKA MEMBUAT VIDEO STEGO ---
    
    # 0. Ekstraksi Audio
    audio_cover_path = None 
    if ffmpeg_available and cover_video_path:
        audio_cover_path_m4a = 'audio_cover_temp.m4a' 
        print("Mencoba mengekstrak audio dari video cover (Lossless Copy)...")
        ffmpeg_audio_command_copy = [
            'ffmpeg', '-y', '-i', cover_video_path,
            '-vn', '-c:a', 'copy', audio_cover_path_m4a 
        ]
        
        try:
            subprocess.run(ffmpeg_audio_command_copy, capture_output=True, check=True, timeout=60)
            print(f"Audio berhasil diekstrak (copy) ke: {audio_cover_path_m4a}")
            audio_cover_path = audio_cover_path_m4a
        except subprocess.CalledProcessError as e:
            print(f"Gagal ekstrak audio (copy): {e.stderr.decode('utf-8')}")
            
            # Fallback ke Transcode MP3
            if not audio_cover_path:
                audio_cover_path_mp3 = 'audio_cover_temp.mp3'
                print("Mencoba mengekstrak audio dengan transcode ke MP3...")
                ffmpeg_audio_command_mp3 = [
                    'ffmpeg', '-y', '-i', cover_video_path,
                    '-vn', '-c:a', 'libmp3lame', '-q:a', '2', audio_cover_path_mp3 
                ]
                try:
                    subprocess.run(ffmpeg_audio_command_mp3, capture_output=True, check=True, timeout=60)
                    print(f"Audio berhasil diekstrak (MP3) ke: {audio_cover_path_mp3}")
                    audio_cover_path = audio_cover_path_mp3
                except subprocess.CalledProcessError as e_mp3:
                    print(f"Gagal ekstrak audio (MP3): {e_mp3.stderr.decode('utf-8')}")
                    audio_cover_path = None 
        
    selected_codec_name = codec_dropdown_get
    
    # 1. Tentukan codec perantara (Video Stream Saja - RAW/Tak Terkompresi)
    # HANYA MENGGUNAKAN HUFFYUV SEBAGAI INTERMEDIATE LOSSLESS
    temp_video_path = 'stego_temp_lossless.avi'
    cap = cv2.VideoCapture(cover_video_path)
    if not cap.isOpened(): raise ValueError("Tidak dapat membuka video asli")
    
    fps = cap.get(cv2.CAP_PROP_FPS)
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

    if os.path.exists(temp_video_path): os.remove(temp_video_path)
        
    # Prioritas 1: Coba HFYU (codec lossless klasik)
    temp_codec_str = 'HFYU'
    temp_fourcc_val = cv2.VideoWriter_fourcc(*temp_codec_str)
    print(f"Mencoba membuka VideoWriter dengan codec perantara: {temp_codec_str}...")
    out = cv2.VideoWriter(temp_video_path, temp_fourcc_val, fps, (width, height))
    
    if not out.isOpened():
        # Prioritas 2: Fallback ke Lossy MJPG (Jika lossless tidak memungkinkan)
        temp_codec_str = 'MJPG'
        temp_fourcc_val = cv2.VideoWriter_fourcc(*temp_codec_str)
        temp_video_path = 'stego_temp_lossy_fallback.avi' 
        print(f"Gagal HFYU. Mencoba membuka VideoWriter dengan codec fallback: {temp_codec_str} (LOSS PERLU DIWASPADAI)...")
        out = cv2.VideoWriter(temp_video_path, temp_fourcc_val, fps, (width, height))
        
        if not out.isOpened():
             raise ValueError(f"Gagal membuka VideoWriter dengan semua codec perantara.")
    
    # Tulis semua frame ke file perantara
    frame_count = 0
    while True:
        ret, frame = cap.read()
        if not ret: break
        
        if frame_count == cover_frame_index:
            if stego_image.shape[0] != height or stego_image.shape[1] != width:
                stego_resized = cv2.resize(stego_image, (width, height))
                out.write(stego_resized)
            else:
                out.write(stego_image)
        else:
            out.write(frame)
        
        frame_count += 1
    
    cap.release()
    out.release()
    print(f"File perantara ({temp_codec_str}) berhasil dibuat: {temp_video_path} (Video Stream Saja)")

    # 2. Pembuatan Video Final dengan Audio (Menggunakan FFmpeg)
    final_output_path = f'stego_video_final.avi' 
    final_fourcc_info = f"{temp_codec_str} (Intermediate)"
    audio_present = audio_cover_path and os.path.exists(audio_cover_path)

    if ffmpeg_available:
        
        # --- LOGIKA HUFFYUV TRANSCODE LOSSLESS ---
        if ("HuffYuv (HFYU)" in selected_codec_name):
            
            ffmpeg_command = ['ffmpeg', '-y']
            ffmpeg_command.extend(['-i', temp_video_path])
            
            if audio_present:
                ffmpeg_command.extend(['-i', audio_cover_path])

            final_output_path = 'stego_video_huffyuv_final.avi'
            print(f"Melakukan FORCE TRANSCODE ke Huffyuv (Lossless Bit-Perfect) menggunakan FFmpeg...")
            
            # Format Piksel BGR24 untuk Lossless Maksimum (cocok dengan output OpenCV)
            final_codec_opts = ['-c:v', 'huffyuv', '-pix_fmt', 'bgr24'] 
            final_fourcc_info = "Huffyuv + Audio (FFmpeg - Force Transcode BGR24)"
            
            ffmpeg_command.extend(final_codec_opts)

            if audio_present:
                ffmpeg_command.extend([
                    '-c:a', 'copy',         
                    '-map', '0:v:0',        
                    '-map', '1:a:0'         
                ])
            else:
                ffmpeg_command.extend(['-map', '0:v:0'])

            ffmpeg_command.append(final_output_path)
            
            try:
                subprocess.run(ffmpeg_command, capture_output=True, check=True, timeout=1800)
                if os.path.exists(final_output_path) and os.path.getsize(final_output_path) > 0:
                     os.remove(temp_video_path)
            except subprocess.CalledProcessError as e:
                error_output = e.stderr.decode('utf-8')
                print(f"Gagal konversi/transcode HuffYuv:\n{error_output}")
                final_output_path = temp_video_path 
                final_fourcc_info = temp_codec_str
                print("Gagal konversi. Menggunakan file perantara.")
        
        # --- LOGIKA WEB M LOSSLESS (VP9) ---
        elif "WebM Lossless (VP9)" in selected_codec_name:
            
            ffmpeg_command = ['ffmpeg', '-y']
            ffmpeg_command.extend(['-i', temp_video_path])
            
            if audio_present:
                ffmpeg_command.extend(['-i', audio_cover_path])

            final_output_path = 'stego_video_vp9_lossless.webm'
            print(f"Melakukan FORCE TRANSCODE ke WebM Lossless (VP9) menggunakan FFmpeg...")
            print("PERHATIAN: WebM Lossless (VP9) adalah mode eksperimental. Uji BER wajib dilakukan.")
            
            # VP9 Lossless flags: libvpx-vp9, -lossless 1, -pix_fmt yuv444p
            ffmpeg_command.extend([
                '-c:v', 'libvpx-vp9', 
                '-lossless', '1',
                '-pix_fmt', 'yuv444p', # Full chroma resolution (4:4:4)
                '-qmin', '0', '-qmax', '0' # VBR flags often set for pure lossless 
            ])
            
            # Mapping
            if audio_present:
                # Transcode audio ke Opus (codec audio standar untuk WebM)
                ffmpeg_command.extend([
                    '-c:a', 'libopus', '-b:a', '128k',         
                    '-map', '0:v:0',        
                    '-map', '1:a:0'         
                ])
                final_fourcc_info = "VP9 Lossless + Opus Audio (FFmpeg - WebM)"
            else:
                ffmpeg_command.extend(['-map', '0:v:0'])
                final_fourcc_info = "VP9 Lossless (FFmpeg - WebM)"

            ffmpeg_command.append(final_output_path)
            
            try:
                subprocess.run(ffmpeg_command, capture_output=True, check=True, timeout=1800)
                if os.path.exists(final_output_path) and os.path.getsize(final_output_path) > 0:
                     os.remove(temp_video_path)
            except subprocess.CalledProcessError as e:
                error_output = e.stderr.decode('utf-8')
                
                if 'Unknown encoder' in error_output or 'Encoder not found' in error_output:
                    print(f"ERROR: Codec VP9 (libvpx-vp9) TIDAK TERSEDIA di FFmpeg Anda.")
                    print("FFmpeg harus dikompilasi dengan '--enable-libvpx'.")
                else:
                    print(f"Gagal konversi ke WebM Lossless:\n{error_output}")
                
                print("--- FALLBACK: Menggunakan file perantara Lossless (HFYU) ---")
                
                final_output_path = temp_video_path
                final_fourcc_info = temp_codec_str
        
        # --- LOGIKA H.264 Lossless (FIXED: Perbaiki urutan input) ---
        elif "H.264 Lossless" in selected_codec_name:
            
            ffmpeg_command = ['ffmpeg', '-y']
            ffmpeg_command.extend(['-i', temp_video_path])
            
            if audio_present:
                ffmpeg_command.extend(['-i', audio_cover_path])

            final_output_path = 'stego_video_h264_lossless.mp4'
            print(f"Melakukan konversi ke H.264 Lossless MP4 menggunakan FFmpeg...")
            print("PERINGATAN: H.264 Lossless (CRF 0) SANGAT MUNGKIN merusak bit stego karena subsampling warna.")

            ffmpeg_command.extend([
                '-c:v', 'libx264', '-preset', 'veryslow', '-crf', '0',
                '-pix_fmt', 'bgr0', 
            ])
            
            if audio_present:
                ffmpeg_command.extend([
                    '-c:a', 'copy',         
                    '-map', '0:v:0',        
                    '-map', '1:a:0'         
                ])
                final_fourcc_info = "H.264 Lossless + Audio (FFmpeg)"
            else:
                ffmpeg_command.extend(['-map', '0:v:0'])
                final_fourcc_info = "H.264 Lossless (FFmpeg - No Audio)"
            
            ffmpeg_command.append(final_output_path)
            
            try:
                subprocess.run(ffmpeg_command, capture_output=True, check=True, timeout=2500)
                if os.path.exists(final_output_path) and os.path.getsize(final_output_path) > 0:
                     os.remove(temp_video_path)
            except subprocess.CalledProcessError as e:
                error_output = e.stderr.decode('utf-8')
                
                print("\n--- KEGAGALAN H.264 ---")
                
                if 'Unknown decoder' in error_output or 'Decoder not found' in error_output:
                    print(f"ERROR: Codec H.264 (libx264) TIDAK TERSEDIA di FFmpeg Anda.")
                else:
                    print(f"Gagal konversi ke H.264 Lossless:\n{error_output}")
                
                print("--- FALLBACK: Menggunakan file perantara Lossless (HFYU) ---")
                
                final_output_path = temp_video_path
                final_fourcc_info = temp_codec_str
                
        # --- LOGIKA Fallback (Jika hanya file perantara) ---
        else:
            if os.path.exists(final_output_path): os.remove(final_output_path)
            os.rename(temp_video_path, final_output_path)
            final_fourcc_info = f"{temp_codec_str} ({final_output_path.split('.')[-1]})"

    else:
        # Jika FFmpeg tidak tersedia sama sekali, hanya ganti nama file perantara
        if os.path.exists(final_output_path): os.remove(final_output_path)
        os.rename(temp_video_path, final_output_path)
        final_fourcc_info = f"{temp_codec_str} ({final_output_path.split('.')[-1]})"

    # 3. Cleanup & Ekstraksi Audio Stego
    audio_stego_path = None
    if ffmpeg_available and final_output_path and os.path.exists(final_output_path):
        
        # Tentukan nama file sementara untuk audio stego
        # GANTI: Menggunakan ekstensi .mp3 dan memaksa transcode untuk kompatibilitas universal
        temp_stego_audio_file = 'audio_stego_temp.mp3' 
        
        print("Mencoba mengekstrak audio dari video stego...")
        
        # Perintah FFmpeg: Ekstrak audio dari video stego (final_output_path)
        ffmpeg_stego_audio_command = [
            'ffmpeg', '-y', '-i', final_output_path,
            '-vn', 
            '-c:a', 'libmp3lame',  # Transcode ke MP3
            '-q:a', '2',           # Kualitas tinggi (q:a 2)
            temp_stego_audio_file
        ]
        
        try:
            subprocess.run(ffmpeg_stego_audio_command, capture_output=True, check=True, timeout=60)
            
            # Cek apakah file berhasil dibuat dan memiliki ukuran > 0 (artinya ada audio stream)
            if os.path.exists(temp_stego_audio_file) and os.path.getsize(temp_stego_audio_file) > 0:
                print(f"Audio stego berhasil diekstrak (transcode MP3) ke: {temp_stego_audio_file}")
                audio_stego_path = temp_stego_audio_file
            else:
                # Jika file dibuat tetapi kosong
                print("Ekstraksi audio stego berhasil dieksekusi, tetapi file kosong (kemungkinan video tanpa audio).")
                if os.path.exists(temp_stego_audio_file):
                    os.remove(temp_stego_audio_file) # Hapus file kosong
                audio_stego_path = None
                
        except subprocess.CalledProcessError as e:
            print(f"Gagal ekstrak audio stego: {e.stderr.decode('utf-8')}")
            audio_stego_path = None
    
    # Update nilai return
    output_video_path = final_output_path
    selected_fourcc_info = final_fourcc_info

    stop_event.set()
    monitor_thread.join()

    end_time = time.time()

    avg_cpu = sum(cpu_samples) / len(cpu_samples) if cpu_samples else 0
    max_cpu = max(cpu_samples) if cpu_samples else 0
    max_ram = max(ram_samples) if ram_samples else 0

    print("\n--- PERFORMA PENYISIPAN ---")
    print(f"Waktu penyisipan        : {end_time - start_time:.3f} detik")
    print(f"CPU rata-rata (%)    : {avg_cpu:.2f}")
    print(f"CPU maksimum (%)     : {max_cpu:.2f}")
    print(f"RAM maksimum (MB)    : {max_ram:.2f}")
    print("-----------------------------")
    print(f"PSNR: {nilai_psnr:.2f} dB, MOS: {nilai_mos}\n")

    return (stego_image, nilai_psnr, nilai_mos, output_video_path, 
            selected_fourcc_info, new_signal_sebaris[:20], total_bits, embedding_strength, bit_pesan_full,
            audio_cover_path, audio_stego_path)